1.常用的服务器模型:1.循环模型、并发模型、io服务器模型
2.什么是io操作:在内存中，只要发生数据交换的操作都成为io操作 
3.IO密集型程序对cpu的资源消耗少，时间大部分都花费在了io等待的过程中，比如一个网络请求有时候会消耗几百毫秒甚至几秒。
4.对io多路复用的理解：以往并发服务器模型中往往都需要建立大量的进程或者线程用来并发处理网络请求，
                但是会给服务器造成很大的负担消耗资源也比较多。所以还是要用到单进程，不过单进程无法同时监听
                多个io请求，只能一个个处理。但是io服务器模型可以在单进程的情况下同时监听多
                个io事件，哪一个准备就绪进程就处理哪个，大大提升了服务端程序的执行效率，类似
                于并发模型服务器的处理方式。
5.io多路复用：在单进程的情况下能够同时监听多个IO事件，当哪个事件就绪就执行哪个IO事件，形成一种
             一种并发的效果。
6.io事件的分类：阻塞io、非阻塞io、io多路复用、事件驱动io、异步io
7.在众多后台语言中都有select、poll、epoll方法用来实现io多路复用，python的select模块中有这三个方法
8.对select函数用法的理解，它的功能是监控多个io事件，参数rlist列表会存放你将要处理的io事件，wlist列
  表会存放你要主动处理的io事件，xlist列表存放发生异常的io事件，函数的返回值也是这三个列表。select函数
  是一个阻塞函数，结束阻塞的条件就是监控的io事件中有一个或者多个可以处理的时候结束阻塞。
9.使用io多路复用的并发量远远高于多进程的并发量，但是io多路复用不能使用计算机的多核资源，
  只适合于io并发，但是网络请求事件往往就是io并发。
10.IO多路复用的特点：1.可以同时监听多种io事件，当任意io事件发生时会处理，在处理每个事件时，
                      不能出现死循环阻塞状态(长期占有服务器);
                    2.IO多路复用，是基于IO的处理，不是多进程或者多线程

易混淆点:rlist可以理解为一种被动行为，当客户端达到io条件的时候，这里面的io事件才算准
        备就绪，就比如客户端向服务器发送了一个请求，需要服务器返回信息。wlist中只要存
        在io事件，select函数就会立即返回做相关处理。




-------------------------------------------------------------------------

poll多路复用（原理跟select实现多路复用的方式一样，都是同时监控多个io事件，只要有任意一个事件准备就绪就进行处理)

使用方法:
    1.创建poll对象（通过poll函数创建一个对象,不需要传递参数)
    p = select.poll()

    2.在这个对象中加入需要关注的IO事件(这里跟select的区别就在于不需要将事件加到具体的三个列表中，并且三个列表也表示了不同的意思)
    p.register(s)

    3.阻塞监控哪个io事件准备就绪，并且它的返回值是一个events列表
    events = p.poll()
    返回值：[(1,evnet),(2,evnet),(3,event)]  列表中每一个元素都是一个元组，然后这个元组中包含两个元素，第一个元素是
           fileno描述符，也就是说每一个io事件，它在操作系统的内核中都会被分配一个整型的数字，成为了io事件的描述符，并
           且内核分配的描述符都不重复，所以说根据描述符不同，就能确定是哪个io事件准备就绪需要进行处理。第二个参数代表
           准备就绪的事件，在select函数中准备就绪的io事件分别放到了不同的列表中，如果在rlist列表中相当于是一个读io事件，
           在wlist中代表的是写io事件，xlist中代表错误io事件。在poll方法参数中只需要添加一个套接字监听io事件即可，只不过
           是在返回值中根据描述符来确定到底发生了什么io事件。

           但是poll函数的返回值不能跟select方法返回的io事件对象那样直接可以使用，
           这时候如果要获取返回的io对象，就需要提前建立好一个自定义的字典，用来存储
           描述符跟io事件之间的关系，通过描述符来找到对应的io事件。
    
    4. 将事件移除监控范围   p.unregister(s)

上述总结：
io多路复用模型(select、poll)、并发服务器模型(多进线程)、循环服务器模型、协程服务器模型
基本原理：通过去关注我们设置的文件描述符或者io事件，然后把它提交给操作系统内核，
         让内核帮我们去交控，当内核中的io事件准备就绪的时候，它会反馈给我们的
         应用层，应用层再对相应的事件进行处理。

io多路复用的方式:select、poll、epoll

epoll 也是一种io多路复用的方式，效率比select和poll要高一点
1.因为select和poll都是让内核帮我们去监控事件，当有就绪事件到应用
层的时候都需要我们再轮询这些事件，找出哪个是就绪事件，如果轮询的
信息量大的话，就会导致每次轮询都需要消耗大量时间，并且提升服务器的压力。而
epoll在内核中，当有就绪事件时直接帮我们查找到具体哪个io事件已经准备就绪。
然后再返回到应用层的时候，直接把准备好的io事件返回到应用层，省掉了轮询
这个步骤。
2.epoll不仅支持水平出发，也支持边缘触发。举例子送快递或者问度娘。

------------------------------------------------------------------------------------
协程

协程（微线程）

解释：它只不过是在使用上和创建上和线程的风格有一点点类似，但实际上它并不能够完成
真正意义上的多核并发，它本质上就是一个单线程（用户态的轻量级线程）

定义：是一种用户态的轻量级线程（用户态只的是协程的创建根本不会用到内核）

特点: 1.轻量级，创建消耗资源非常少，比线程还要小很多
      2.不涉及内核，就是一个应用层的概念
      3.非常适用于高并发的io场景

优点：无需上下文切换的开销也就是cpu切换进程或者线程，无需同步互斥的操作，有较高的并发性，创建资源消耗少

缺点：无法利用计算机的多核资源，遇到死循环等阻塞状态会影响整个程序的运行。

如何创建协程：
greenlet  gevent evenless stackless实现协程的模块









 