# Python 第一阶段面试题


## 1.python是如何进行内存管理的?
###  引入计数
    首先python引入了一个机制:引用计数,python内部使用引用计数，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。
    总结一下:
    对象会在一下情况下引用计数加1：

    1.对象被创建：x=4

    2.另外的别人被创建：y=x

    3.被作为参数传递给函数：func(x)

    4.作为容器对象的一个元素：a=[1,x,'ab;]

    引用计数减少情况

    1.一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1。

    2.对象的别名被显式的销毁：del x ；或者del y

    3.对象的一个别名被赋值给其他对象：x=789

    4.对象从一个窗口对象中移除：myList.remove(x)

    5.窗口对象本身被销毁：del myList，或者窗口对象本身离开了作用域。

### 垃圾回收
    1、当内存中有不再使用的部分时，垃圾收集器就会把他们清理掉。它会去检查那些引用计数为0的对象，然后清除其在内存的空间。当然除了引用计数为0的会被清除，还有一种情况也会被垃圾收集器清掉：当两个对象相互引用时，他们本身其他的引用已经为0了。

    2、垃圾回收机制还有一个循环垃圾回收器, 确保释放循环引用对象(a引用b, b引用a, 导致其引用计数永远不为0)。

    在Python中，许多时候申请的内存都是小块的内存，这些小块内存在申请后，很快又会被释放，由于这些内存的申请并不是为了创建对象，所以并没有对象一级的内存池机制。这就意味着Python在运行期间会大量地执行malloc和free的操作，频繁地在用户态和核心态之间进行切换，这将严重影响Python的执行效率。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。

### 内存池机制
    Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。

    Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的 malloc。另外Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。

## 2.谈谈对闭包的理解
    在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是这个内函数,这样就构成了一个闭包,而此时这个内函数就是一个闭包函数.
        闭包还必须具备三个条件:
            1. 必须有一个内嵌函数 
            2. 内嵌函数必须引用外部函数中的变量
            3. 外部函数返回值必须是内嵌函数
    一般情况下，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。

    注意点:由于闭包会使得函数中的变量都被保留在内存中,内存消耗比较大,所以不能滥用闭包

## 3.用自己的话说明迭代器和生成器，它们之间的关系？
pass

## 4.装饰器
```txt
    python装饰器本质上就是一个函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外的功能，装饰器的返回值也是一个函数对象.装饰器函数的外部函数传入我要装饰的函数名字，返回经过修饰后函数的名字；内层函数（闭包）负责修饰被修饰函数。从上面这段描述中我们需要记住装饰器的几点属性，以便后面能更好的理解：

       实质： 是一个函数

　　　　参数：是你要装饰的函数名（并非函数调用）

　　　　返回：是装饰完的函数名（也非函数调用）

　　　　作用：为已经存在的对象添加额外的功能

　　　　特点：不需要对对象做任何的代码上的变动


python装饰器有很多经典的应用场景，比如：插入日志、性能测试、事务处理、权限校验等。装饰器是解决这类问题的绝佳设计。并且从引入中的列子中我们也可以归纳出：装饰器最大的作用就是对于我们已经写好的程序，我们可以抽离出一些雷同的代码组建多个特定功能的装饰器，这样我们就可以针对不同的需求去使用特定的装饰器，这时因为源码去除了大量泛化的内容而使得源码具有更加清晰的逻辑。
```
```py
#1. 函数的函数装饰器
#示例以为函数添加计时功能为例，讲述函数装饰器。
import time
def decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        func()
        end_time = time.time()
        print(end_time - start_time)

    return wrapper

@decorator 
def func():
    time.sleep(0.8)
func() # 函数调用  原理是让myfunc重新绑定mydeco返回回来的函数:myfunc = mydeco(myfunc)

# -------------------------------------------------------------------------------

#2.类方法的函数装饰器
# 类方法的函数装饰器和函数的函数装饰器类似。
import time

def decorator(func):
    def wrapper(me_instance):
        start_time = time.time()
        func(me_instance)
        end_time = time.time()
        print(end_time - start_time)
    return wrapper

class Method(object):

    @decorator 
    def func(self):
        time.sleep(0.8)

p1 = Method()
p1.func() # 函数调用

'''对于类方法来说，都会有一个默认的参数self，它实际表示的是类的一个实例，所以在装饰器的内部函数wrapper也要传入一个参数 - me_instance就表示将类的实例p1传给wrapper，其他的用法都和函数装饰器相同。'''

# -------------------------------------------------------------------------------

# 3.类装饰器
'''前面我们提到的都是让 函数作为装饰器去装饰其他的函数或者方法，那么可不可以让 一个类发挥装饰器的作用呢？答案肯定是可以的，一切皆对象嚒，函数和类本质没有什么不一样。类的装饰器是什么样子的呢？'''
class Decorator(object):
    def __init__(self, f):
        self.f = f
    def __call__(self):
        print("decorator start")
        self.f()
        print("decorator end")

@Decorator
def func():
    print("func")

func()

'''
这里有注意的是：__call__()是一个特殊方法，它可将一个类实例变成一个可调用对象:
p = Decorator(func) # p是类Decorator的一个实例
p()                 # 实现了__call__()方法后，p可以被调用
'''

```







## Cookie:
### 1.函数内变量的生命周期:内部变量在每次函数被调用时重新创建，在函数结束时销毁。
### 2.函数是python中的一级对象
```plaintext
今天算是长姿势了..也明白魏老师为什么将原来一大堆函数嵌套的问题:
(1)在 Python 中有个常识：函数和其他任何东西一样，都是对象。函数包含变量，它并不那么特殊。   上代码↓↓↓
```
```py
    #首先我们要明白Python中的所有对象都继承自一个公共的基类
    # e.g.
    print(issubclass(int,object))  # True

    def foo():
        pass
    print(issubclass(foo.__class__,object))#foo是function类实例出来的对象,结果是True
```
```txt
(2)在 Python 中函数只是常规的值，就像其他任意类型的值一样。这意味着可以将函数当做实参传递给函数，或者在函数中将函数作为返回值返回
```
```py
def add(x,y):
	return x + y
def sub(x,y):
	return x - y
def apply(func,x,y):
	return func(x,y)

print(apply(add,2,1)) # 3

print(apply(sub,2,1)) # 1
```

    
    




