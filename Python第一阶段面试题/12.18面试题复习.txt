进程:
    (1)当父子进程创建完毕后,他们之间有着争夺cpu资源的关系,有可能是并行执行也有可能是并发执行
    父进程的pid号对应的是子进程的pid号,子进程的pid号
    (2)当父进程结束之后,会失去对终端的控制,命令行会被打印到终端,此时子进程还在运行,所以会导致
        子进程打印的东西在终端命令行之后.
    (3)终端查看任务管理器  
        ps -aux 
       查看僵尸进程的代号   Z+
    (4)僵尸进程虽然结束但是会存留部分进程信息在内存中,大量的僵尸进程会消耗系统资源,因此应该避免僵尸进程产生
    处理僵尸进程:
        pid,status = os.wait()  #父进程阻塞等待处理僵尸进程
        状态值为子进程退出方法中的参数值,如果为2 ---> 512
        还原参数:   os.WEXITSTATUS(status)
        os.wait()简直是对进程的侮辱:
            为了不让子进程变成僵尸进程,在父进程中添加wait(),不符合进程的做法,不推荐.由此引进二级子进程
    ** 总结:os.fork()此方法创建子进程是python创建进程的底层方法,是创建进程的原理,他也有局限性,如果想要
        完成多个任务,必须一直建立子进程,并且也不方便.
    ** 但python中的multiprocessing模块已经把创建进程的方法给出,直接运用
    import multiprocessing as mp
    p = mp.Process(target=函数名,参数)
    p.start()
    #回收进程
    p.join()
    ** 但是这种方法还是有缺陷,问题跟fork一样,是对进程的侮辱,父进程的join()阻塞等待子进程的退出
    整体上还是浪费一个进程,所以我们运用multiprocessing还是得创建多个类似于fork创建二级子进程的
    方法一样,父进程只做两件事就是创建进程和处理进程,其他的多个事情全部交给创建的多个子进程进行处理
    **p.daemon()参数默认为false,表示主进程退出,不会影响子进程继续运行.设置为true的时候表示父进程
    退出子进程也会跟着一起退出,这样的话僵尸进程全部交给操作系统去处理,不过代码中p.daemon一定要写在p.start
    之前,并且代码中不能出现p.join()来阻塞回收进程.否则毫无意义.

        


