1.优点:多进程的好处:可以利用计算机的多核资源进行多任务并发或并行的操作,用于提高程序的效率. 
  缺点:进程的创建和删除过程需要消耗较多的系统资源.大量进程频繁的创建删除会给操作系统带来压力
2.如果计算机需要处理的任务量很大,同时也会不断的发生,也有可能在很短的事件内结束,我们就要频繁的
  创建和回收进程,则会占用不少计算机的资源
3.为应对这个缺点引进了进程池技术: (后期爬虫也会用到进程池.同时抓取和下载多个网络资源)
  进程池技术标志:事件结束后而进程不退出,继续等待处理下一个事件,知道把所有事件做完后,进程池再推出
  (相当于家里的衣柜,里面有衣架,当你取出一件衣服的时候,下次还可以在挂上)
4.操作系统中存在并行和并发
    并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔发生。
    在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统
    中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。
5.进程池原理:
    创建一定量的进程作为进程池,用来处理事件.
    事件处理完毕后,进程不退出,而是继续等待处理其他事件.
    直到所有待处理事件处理完毕后统一销毁进程.增加了进程的重复利用,降低资源消耗.
6.创建进程池,需要执行的进程函数通常放在pool=Pool()的上面,需要注意pool.join()方法,
  阻塞回收进程,如果去掉后主进程结束那么进程池也会结束.
7.从进程池技术开始引入概念同步执行和异步执行:
    同步执行:比如你做两件事或多件事,你做后一件事情的前提必须是前一件事情已经完成了, 也就是
             干完一件事才能去干下一件事情.
    异步执行: 第一件事没干完就可以去干下一件事,那我没干完的这件事就交给你了,执行效率更高,选择性
              更高. 
8. pool.apply_async(func=(),args=())  异步执行,返回值为进程对象
   pool.apply(func=(),args=())        同步执行,没有返回值,没卵用,浪费进程池技术
   pool.map(func,iter)                进程个数有可迭代对象决定,依次2个2个放入进程池,返回值:函数的返回值列表


---------------------------------
关注度比较高的进程间通信方式: 管道  消息队列  共享内存  信号(底层)  信号量  套接字(使用最多)
(1) 管道通信(pipe),在内存中开辟控件,保密性比较好,进程结束后管道也会被销毁,可以单向也可以双向,进程间
    使用同一组管道对象进程读写实现通信.它创建的时间必须在进程创建之前,是由子进程拷贝父进程内容的时候顺带就被
    拷贝过去,这样的话父子进程就会使用同一组管道对象

     双向管道:两端都可以读写
    单向管道:一端读一端写   fd1对象只能读 fd1.recv()  fd2对象只能写 fd2.send()
    from multiprocessing import Process,Pipe
import os,time

fd1,fd2 = Pipe() #管道参数默认为True,表示双向管道
def fun(name):
    time.sleep(3)
    fd1.send("hello! "+ name.title())

jobs = []
for i in ['tom','zack','abby','sam']:
    p = Process(target=fun,args=(i,))
    jobs.append(p)
    p.start()

#从管道读取内容
for i in range(4):
    data = fd2.recv()
    print(data)

for i in jobs:
    i.join()
(2)消息队列
    队列的特征:先进先出
from multiprocessing import Queue,Process
from time import sleep

q = Queue()

def fun1():
    for i in range(10):
        sleep(1)
        q.put((2,i))

def fun2():
    for i in range(10):
        sleep(1.5)
        a,b = q.get()
        print(a ** b)

p1 = Process(target = fun1)
p2 = Process(target=fun2)
p1.start()
p2.start()
p1.join()
p2.join()


(3)共享内存不用格式化操作以及打包,就是原生态的计算机内存,所以效率很高,开辟了共享内存之后会自动记录共享内存首地址,
    (首地址就是每段内存的ID) ,以为每次写入的内容都会把之前写入的内容给覆盖,所以本质上只可以存储一条消息.
    特征:虽然共享内存的速度快,但每次都从头写.

    通信原理:在内存中开辟一个区域,对多进程可见,进程可以写入内容或者读取内容,但是
            每次写入的内容都会覆盖之前的,是两个正在运行的进程之间共享和传递数据
            的最有效的传输方式.

from multiprocessing import Process,Value
import time
import random

#创建共享内存
money = Value('i',5000)

def boy():
    for i in range(30):
        time.sleep(0.2)
        #对value属性操作,即操作共享内存
        money.value += random.randint(1,1500)
def girl():
    for i in range(30):
        time.sleep(0.2)
        money.value -= random.randint(100,1200)

b = Process(target=boy)
g = Process(target = girl)
b.start()
g.start()
b.join()
g.join()
print("一个月余额:",money.value)

总结三种进程通信方式:  管道   消息队列   共享内存
三者都是运行的进程间传递消息的方式,都是在内存中开辟内存存入数据,
管道是两端读写;消息队列必须是一端进一端出,即先进先出;共享内存读写会覆盖之前
的内容.共享内存的效率最高

====================================================================================================

1.进程也可以使用计算机的多核资源,也被称为轻量级的进程,占用的资源比例较小,也有生命周期,线程是
  系统分配内核的最小单位(进程是计算机分配资源的最小单位,操作系统不会给线程分配资源,消耗进程的资源
   ,大约是进程的1/20倍创建删除占用的资源消耗非常少,并且可以单独占用一个计算机内核)

2.一个进程包含多个线程,打印主线程和分支线程的进程PID号一样,他们都运行在一个进程上,共享进程的资源,所以说线程
    是在进程空间内开辟的一个部分

注意: 进程中的主线程结束之后,分支线程不会跟着主线程而结束,当所有的线程结束才意味着进程结束
      
同步互斥:
    同步就相当于是一种合作关系,为完成任务,从而形成的一种协调调度,按照必要的步骤有序执行一系列操作
    互斥:是一种制约关系,争夺关系,谁先抢占谁就先使用,不存在先后关系或者说谁先完成谁才能完成的情况.
        (互斥是一种制约的关系,当一个进程或者线程使用临界资源时会执行加锁处理,
        此时另一个进程或者线程就无法操作,直到解锁后才能使用)


python 线程的GIL问题理解:
    因为python解释器加了一个全局锁,导致同一时刻python解释器只能解释一个线程,所以大大降低了Python多线程的执行效率,

    (所以多线程有时候还不如单线程,因为多线程还需要来回切换计算机的内核也有一定量的资源消耗,但是多线程遇到阻塞
    就能发挥它的作用,可以直接跳过阻塞直接执行下一个代码块,节省了阻塞消耗的时间.但如果运行cpu密集程序(持续不断需要运行程序的状态下),
    就直接GG,所以这就是python的GIL问题)


    后果:Pyhon线程一般只能用在大量IO阻塞存在程序中,或则高延迟的IO程序中.遇到阻塞,
    线程会自动让出解释器.而在cpu密集型程序中,python线程效率低下.

    GIL问题建议:
    *尽量使用多进程完成并发
    *不使用c作为解释器情况没有GIL问题
    *使用多种阻塞方案完成并发
    *修改c解释器




















cookie:
为什么要引入进程池:因为普通的创建和回收进程需要消耗一定的计算机内核空间资源,当有大量的任务需要执行的时候,消耗计算机
                  资源多,而进程池可以避免频繁创建进程带来的的系统消耗. 事情处理完毕,进程不退出,知道所有事情做完.\


    




